import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, of, throwError, Subject, isObservable } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort, getStoreMetadata } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
import { NgxsUnhandledActionsLogger } from '../dev-features/ngxs-unhandled-actions-logger';
import * as i0 from "@angular/core";
import * as i1 from "../symbols";
import * as i2 from "../actions-stream";
import * as i3 from "../internal/dispatcher";
import * as i4 from "../internal/state-context-factory";
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
/**
 * The `StateFactory` class adds root and feature states to the graph.
 * This extracts state names from state classes, checks if they already
 * exist in the global graph, throws errors if their names are invalid, etc.
 * See its constructor, state factories inject state factories that are
 * parent-level providers. This is required to get feature states from the
 * injector on the same level.
 *
 * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.
 * The `StateFactory` is initialized on the feature level and goes through `...states`
 * to get them from the injector through `injector.get(state)`.
 * @ignore
 */
export class StateFactory {
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize(() => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const stateFactory = this;
            function resolveGetter(key) {
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.'), stateFactory._config) : null;
            }
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter(key) {
                        let getter = resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        };
                    },
                    getSelectorOptions(localOptions) {
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));
                    }
                };
            return context;
        });
    }
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    static cloneDefaults(defaults) {
        let value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    ngOnDestroy() {
        var _a;
        (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses) {
        if (NG_DEV_MODE) {
            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        const stateGraph = buildGraph(newStates);
        const sortedStates = topologicalSort(stateGraph);
        const paths = findFullParentPath(stateGraph);
        const nameGraph = nameToState(newStates);
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            const stateClass = nameGraph[name];
            const path = paths[name];
            const meta = stateClass[META_KEY];
            this.addRuntimeInfoToMeta(meta, path);
            // Note: previously we called `ensureStateClassIsInjectable` within the
            // `State` decorator. This check is moved here because the `Éµprov` property
            // will not exist on the class in JIT mode (because it's set asynchronously
            // during JIT compilation through `Object.defineProperty`).
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                ensureStateClassIsInjectable(stateClass);
            }
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses) {
        const classes = stateClasses || [];
        const mappedStores = this.add(classes);
        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});
        return { defaults, states: mappedStores };
    }
    connectActionHandlers() {
        // Note: We have to connect actions only once when the `StateFactory`
        //       is being created for the first time. This checks if we're in
        //       a child state factory and the parent state factory already exists.
        if (this._parentFactory || this._actionsSubscription !== null) {
            return;
        }
        const dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* Dispatched */), mergeMap(ctx => {
            dispatched$.next(ctx);
            const action = ctx.action;
            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: "SUCCESSFUL" /* Successful */ })), defaultIfEmpty({ action, status: "CANCELED" /* Canceled */ }), catchError(error => of({ action, status: "ERRORED" /* Errored */, error })));
        }))
            .subscribe(ctx => this._actionResults.next(ctx));
    }
    /**
     * Invoke actions on the states.
     */
    invokeActions(dispatched$, action) {
        const type = getActionTypeFromInstance(action);
        const results = [];
        // Determines whether the dispatched action has been handled, this is assigned
        // to `true` within the below `for` loop if any `actionMetas` has been found.
        let actionHasBeenHandled = false;
        for (const metadata of this.states) {
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (isObservable(result)) {
                            // If this observable has been completed w/o emitting
                            // any value then we wouldn't want to complete the whole chain
                            // of actions. Since if any observable completes then
                            // action will be canceled.
                            // For instance if any action handler would've had such statement:
                            // `handler(ctx) { return EMPTY; }`
                            // then the action will be canceled.
                            // See https://github.com/ngxs/store/issues/1568
                            result = result.pipe(mergeMap((value) => {
                                if (value instanceof Promise) {
                                    return from(value);
                                }
                                if (isObservable(value)) {
                                    return value;
                                }
                                return of(value);
                            }), defaultIfEmpty({}));
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                    actionHasBeenHandled = true;
                }
            }
        }
        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
        // only during development.
        if (NG_DEV_MODE && !actionHasBeenHandled) {
            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
            // didn't return `null` so we may ensure the module has been imported.
            if (unhandledActionsLogger) {
                unhandledActionsLogger.warn(action);
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    addToStatesMap(stateClasses) {
        const newStates = [];
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            const stateName = getStoreMetadata(stateClass).name;
            if (NG_DEV_MODE) {
                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);
            }
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[meta.name] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    }
    hasBeenMountedAndBootstrapped(name, path) {
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        // This checks whether a state has been already added to the global graph and
        // its lifecycle is in 'bootstrapped' state.
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
/** @nocollapse */ StateFactory.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: i1.NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: i2.InternalActions }, { token: i3.InternalDispatchedActionResults }, { token: i4.StateContextFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ÉµÉµFactoryTarget.Injectable });
/** @nocollapse */ StateFactory.Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory });
i0.ÉµÉµngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.NgxsConfig }, { type: StateFactory, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i2.InternalActions }, { type: i3.InternalDispatchedActionResults }, { type: i4.StateContextFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INITIAL_STATE_TOKEN]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzVGLE9BQU8sRUFDTCxRQUFRLEVBQ1IsSUFBSSxFQUVKLEVBQUUsRUFDRixVQUFVLEVBRVYsT0FBTyxFQUNQLFlBQVksRUFDYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsbUJBQW1CLEVBQWlCLE9BQU8sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBGLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2xELE9BQU8sRUFDTCxVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFFBQVEsRUFHUixXQUFXLEVBQ1gsVUFBVSxFQUtWLGVBQWUsRUFHZixnQkFBZ0IsRUFDakIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQStCLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM5RSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQzs7Ozs7O0FBRTNGLE1BQU0sV0FBVyxHQUFHLE9BQU8sU0FBUyxLQUFLLFdBQVcsSUFBSSxTQUFTLENBQUM7QUFFbEU7Ozs7Ozs7Ozs7OztHQVlHO0FBRUgsTUFBTSxPQUFPLFlBQVk7SUFHdkIsWUFDVSxTQUFtQixFQUNuQixPQUFtQixFQUduQixjQUE0QixFQUM1QixRQUF5QixFQUN6QixjQUErQyxFQUMvQyxvQkFBeUMsRUFHekMsYUFBa0I7UUFWbEIsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUNuQixZQUFPLEdBQVAsT0FBTyxDQUFZO1FBR25CLG1CQUFjLEdBQWQsY0FBYyxDQUFjO1FBQzVCLGFBQVEsR0FBUixRQUFRLENBQWlCO1FBQ3pCLG1CQUFjLEdBQWQsY0FBYyxDQUFpQztRQUMvQyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXFCO1FBR3pDLGtCQUFhLEdBQWIsYUFBYSxDQUFLO1FBYnBCLHlCQUFvQixHQUF3QixJQUFJLENBQUM7UUFnQmpELFlBQU8sR0FBa0IsRUFBRSxDQUFDO1FBTTVCLGtCQUFhLEdBQWlCLEVBQUUsQ0FBQztRQU1qQyxnQkFBVyxHQUEwQixFQUFFLENBQUM7UUFNaEQsOEJBQXlCLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRTtZQUN2Qyw0REFBNEQ7WUFDNUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDO1lBRTFCLFNBQVMsYUFBYSxDQUFDLEdBQVc7Z0JBQ2hDLE1BQU0sSUFBSSxHQUFHLFlBQVksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUN6RSxDQUFDO1lBRUQsTUFBTSxPQUFPLEdBQTJCLElBQUksQ0FBQyxjQUFjO2dCQUN6RCxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyx5QkFBeUIsRUFBRTtnQkFDakQsQ0FBQyxDQUFDO29CQUNFLGNBQWMsQ0FBQyxHQUFXO3dCQUN4QixJQUFJLE1BQU0sR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ2hDLElBQUksTUFBTSxFQUFFOzRCQUNWLE9BQU8sTUFBTSxDQUFDO3lCQUNmO3dCQUNELE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRSxFQUFFOzRCQUNqQixxQkFBcUI7NEJBQ3JCLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0NBQ1gsTUFBTSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQzs2QkFDN0I7NEJBQ0QsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7d0JBQzlDLENBQUMsQ0FBQztvQkFDSixDQUFDO29CQUNELGtCQUFrQixDQUFDLFlBQW9DO3dCQUNyRCxNQUFNLHFCQUFxQixHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDO3dCQUNuRSx1Q0FDSyxxQkFBcUIsR0FDckIsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLEVBQ3ZCO29CQUNKLENBQUM7aUJBQ0YsQ0FBQztZQUNOLE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO0lBdERBLENBQUM7SUFJSixJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3pFLENBQUM7SUFJRCxJQUFJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQ3JGLENBQUM7SUFJRCxJQUFZLFVBQVU7UUFDcEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUNqRixDQUFDO0lBc0NPLE1BQU0sQ0FBQyxhQUFhLENBQUMsUUFBYTtRQUN4QyxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7UUFFZixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDM0IsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUMxQjthQUFNLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzdCLEtBQUsscUJBQVEsUUFBUSxDQUFFLENBQUM7U0FDekI7YUFBTSxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDakMsS0FBSyxHQUFHLEVBQUUsQ0FBQztTQUNaO2FBQU07WUFDTCxLQUFLLEdBQUcsUUFBUSxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsV0FBVzs7UUFDVCxNQUFBLElBQUksQ0FBQyxvQkFBb0IsMENBQUUsV0FBVyxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOztPQUVHO0lBQ0gsR0FBRyxDQUFDLFlBQWtDO1FBQ3BDLElBQUksV0FBVyxFQUFFO1lBQ2YsZUFBZSxDQUFDLHNDQUFzQyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3RFO1FBRUQsTUFBTSxFQUFFLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNO1lBQUUsT0FBTyxFQUFFLENBQUM7UUFFakMsTUFBTSxVQUFVLEdBQWtCLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4RCxNQUFNLFlBQVksR0FBYSxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDM0QsTUFBTSxLQUFLLEdBQTBCLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sU0FBUyxHQUFzQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDNUUsTUFBTSxrQkFBa0IsR0FBa0IsRUFBRSxDQUFDO1FBRTdDLEtBQUssTUFBTSxJQUFJLElBQUksWUFBWSxFQUFFO1lBQy9CLE1BQU0sVUFBVSxHQUF1QixTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkQsTUFBTSxJQUFJLEdBQVcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2pDLE1BQU0sSUFBSSxHQUFrQixVQUFVLENBQUMsUUFBUSxDQUFFLENBQUM7WUFFbEQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUV0Qyx1RUFBdUU7WUFDdkUsMkVBQTJFO1lBQzNFLDJFQUEyRTtZQUMzRSwyREFBMkQ7WUFDM0QsSUFBSSxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxFQUFFO2dCQUNqRCw0QkFBNEIsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUMxQztZQUVELE1BQU0sUUFBUSxHQUFnQjtnQkFDNUIsSUFBSTtnQkFDSixJQUFJO2dCQUNKLGFBQWEsRUFBRSxLQUFLO2dCQUNwQixPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ3JCLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7Z0JBQ3hDLFFBQVEsRUFBRSxZQUFZLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7YUFDcEQsQ0FBQztZQUVGLDZDQUE2QztZQUM3Qyx5Q0FBeUM7WUFDekMsOEJBQThCO1lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO2dCQUNuRCxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDbkM7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QjtRQUVELE9BQU8sa0JBQWtCLENBQUM7SUFDNUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsb0JBQW9CLENBQUMsWUFBa0M7UUFDckQsTUFBTSxPQUFPLEdBQXlCLFlBQVksSUFBSSxFQUFFLENBQUM7UUFFekQsTUFBTSxZQUFZLEdBQWtCLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEQsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FDbEMsQ0FBQyxNQUFXLEVBQUUsV0FBd0IsRUFBRSxFQUFFLENBQ3hDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQzFELEVBQUUsQ0FDSCxDQUFDO1FBQ0YsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLENBQUM7SUFDNUMsQ0FBQztJQUVELHFCQUFxQjtRQUNuQixxRUFBcUU7UUFDckUscUVBQXFFO1FBQ3JFLDJFQUEyRTtRQUMzRSxJQUFJLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLG9CQUFvQixLQUFLLElBQUksRUFBRTtZQUM3RCxPQUFPO1NBQ1I7UUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sRUFBaUIsQ0FBQztRQUNqRCxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLFFBQVE7YUFDdEMsSUFBSSxDQUNILE1BQU0sQ0FBQyxDQUFDLEdBQWtCLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLGtDQUE0QixDQUFDLEVBQ3RFLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNiLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEIsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztZQUMxQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLE1BQU8sQ0FBQyxDQUFDLElBQUksQ0FDbEQsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQWUsRUFBRSxNQUFNLEVBQUUsTUFBTSwrQkFBeUIsRUFBRSxDQUFBLENBQUMsRUFDckUsY0FBYyxDQUFnQixFQUFFLE1BQU0sRUFBRSxNQUFNLDJCQUF1QixFQUFFLENBQUMsRUFDeEUsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQ2pCLEVBQUUsQ0FBZ0IsRUFBRSxNQUFNLEVBQUUsTUFBTSx5QkFBc0IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUNuRSxDQUNGLENBQUM7UUFDSixDQUFDLENBQUMsQ0FDSDthQUNBLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsYUFBYSxDQUFDLFdBQXNDLEVBQUUsTUFBVztRQUMvRCxNQUFNLElBQUksR0FBRyx5QkFBeUIsQ0FBQyxNQUFNLENBQUUsQ0FBQztRQUNoRCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFbkIsOEVBQThFO1FBQzlFLDZFQUE2RTtRQUM3RSxJQUFJLG9CQUFvQixHQUFHLEtBQUssQ0FBQztRQUVqQyxLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDbEMsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUzQyxJQUFJLFdBQVcsRUFBRTtnQkFDZixLQUFLLE1BQU0sVUFBVSxJQUFJLFdBQVcsRUFBRTtvQkFDcEMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUM1RSxJQUFJO3dCQUNGLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQzt3QkFFcEUsSUFBSSxNQUFNLFlBQVksT0FBTyxFQUFFOzRCQUM3QixNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO3lCQUN2Qjt3QkFFRCxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTs0QkFDeEIscURBQXFEOzRCQUNyRCw4REFBOEQ7NEJBQzlELHFEQUFxRDs0QkFDckQsMkJBQTJCOzRCQUMzQixrRUFBa0U7NEJBQ2xFLG1DQUFtQzs0QkFDbkMsb0NBQW9DOzRCQUNwQyxnREFBZ0Q7NEJBQ2hELE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUNsQixRQUFRLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtnQ0FDdEIsSUFBSSxLQUFLLFlBQVksT0FBTyxFQUFFO29DQUM1QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztpQ0FDcEI7Z0NBQ0QsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUU7b0NBQ3ZCLE9BQU8sS0FBSyxDQUFDO2lDQUNkO2dDQUNELE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUNuQixDQUFDLENBQUMsRUFDRixjQUFjLENBQUMsRUFBRSxDQUFDLENBQ25CLENBQUM7NEJBRUYsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLGlCQUFpQixFQUFFO2dDQUN4Qyw0REFBNEQ7Z0NBQzVELE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUNsQixTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFhLENBQUMsQ0FBQyxDQUFDLENBQy9ELENBQUM7NkJBQ0g7eUJBQ0Y7NkJBQU07NEJBQ0wsTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQzt5QkFDckM7d0JBRUQsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDdEI7b0JBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDN0I7b0JBRUQsb0JBQW9CLEdBQUcsSUFBSSxDQUFDO2lCQUM3QjthQUNGO1NBQ0Y7UUFFRCw0RUFBNEU7UUFDNUUsMkJBQTJCO1FBQzNCLElBQUksV0FBVyxJQUFJLENBQUMsb0JBQW9CLEVBQUU7WUFDeEMsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNwRiwrRUFBK0U7WUFDL0UsMkZBQTJGO1lBQzNGLHNFQUFzRTtZQUN0RSxJQUFJLHNCQUFzQixFQUFFO2dCQUMxQixzQkFBc0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDckM7U0FDRjtRQUVELElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFFRCxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRU8sY0FBYyxDQUFDLFlBQWtDO1FBR3ZELE1BQU0sU0FBUyxHQUF5QixFQUFFLENBQUM7UUFDM0MsTUFBTSxTQUFTLEdBQWlCLElBQUksQ0FBQyxZQUFZLENBQUM7UUFFbEQsS0FBSyxNQUFNLFVBQVUsSUFBSSxZQUFZLEVBQUU7WUFDckMsTUFBTSxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSyxDQUFDO1lBQ3JELElBQUksV0FBVyxFQUFFO2dCQUNmLGVBQWUsQ0FBQywwQkFBMEIsQ0FBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQzlFO1lBQ0QsTUFBTSxjQUFjLEdBQUcsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDN0MsSUFBSSxjQUFjLEVBQUU7Z0JBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzNCLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxVQUFVLENBQUM7YUFDbkM7U0FDRjtRQUVELE9BQU8sRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRU8sb0JBQW9CLENBQUMsSUFBbUIsRUFBRSxJQUFZO1FBQzVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNuQyxxRkFBcUY7UUFDckYsNkVBQTZFO1FBQzdFLHlGQUF5RjtRQUN6RixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRU8sNkJBQTZCLENBQUMsSUFBWSxFQUFFLElBQVk7UUFDOUQsTUFBTSxpQ0FBaUMsR0FDckMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDO1FBQ25ELDZFQUE2RTtRQUM3RSw0Q0FBNEM7UUFDNUMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLGlDQUFpQyxDQUFDO0lBQ3RFLENBQUM7OzZIQW5UVSxZQUFZLG9FQVFHLFlBQVksOEpBSzVCLG1CQUFtQjtpSUFibEIsWUFBWTs0RkFBWixZQUFZO2tCQUR4QixVQUFVOzBHQVNpQixZQUFZOzBCQUZuQyxRQUFROzswQkFDUixRQUFROzswQkFLUixRQUFROzswQkFDUixNQUFNOzJCQUFDLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yLCBPcHRpb25hbCwgU2tpcFNlbGYsIEluamVjdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBmb3JrSm9pbixcbiAgZnJvbSxcbiAgT2JzZXJ2YWJsZSxcbiAgb2YsXG4gIHRocm93RXJyb3IsXG4gIFN1YnNjcmlwdGlvbixcbiAgU3ViamVjdCxcbiAgaXNPYnNlcnZhYmxlXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgZGVmYXVsdElmRW1wdHksXG4gIGZpbHRlcixcbiAgbWFwLFxuICBtZXJnZU1hcCxcbiAgc2hhcmVSZXBsYXksXG4gIHRha2VVbnRpbFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJTklUSUFMX1NUQVRFX1RPS0VOLCBQbGFpbk9iamVjdE9mLCBtZW1vaXplIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcblxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcbmltcG9ydCB7XG4gIGJ1aWxkR3JhcGgsXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcbiAgaXNPYmplY3QsXG4gIE1hcHBlZFN0b3JlLFxuICBNZXRhRGF0YU1vZGVsLFxuICBuYW1lVG9TdGF0ZSxcbiAgcHJvcEdldHRlcixcbiAgU3RhdGVDbGFzc0ludGVybmFsLFxuICBTdGF0ZUtleUdyYXBoLFxuICBTdGF0ZXNBbmREZWZhdWx0cyxcbiAgU3RhdGVzQnlOYW1lLFxuICB0b3BvbG9naWNhbFNvcnQsXG4gIFJ1bnRpbWVTZWxlY3RvckNvbnRleHQsXG4gIFNoYXJlZFNlbGVjdG9yT3B0aW9ucyxcbiAgZ2V0U3RvcmVNZXRhZGF0YVxufSBmcm9tICcuL2ludGVybmFscyc7XG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBnZXRWYWx1ZSwgc2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBvZkFjdGlvbkRpc3BhdGNoZWQgfSBmcm9tICcuLi9vcGVyYXRvcnMvb2YtYWN0aW9uJztcbmltcG9ydCB7IEFjdGlvbkNvbnRleHQsIEFjdGlvblN0YXR1cywgSW50ZXJuYWxBY3Rpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XG5pbXBvcnQgeyBTdG9yZVZhbGlkYXRvcnMgfSBmcm9tICcuLi91dGlscy9zdG9yZS12YWxpZGF0b3JzJztcbmltcG9ydCB7IGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGUgfSBmcm9tICcuLi9pdnkvaXZ5LWVuYWJsZWQtaW4tZGV2LW1vZGUnO1xuaW1wb3J0IHsgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXIgfSBmcm9tICcuLi9kZXYtZmVhdHVyZXMvbmd4cy11bmhhbmRsZWQtYWN0aW9ucy1sb2dnZXInO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZTtcblxuLyoqXG4gKiBUaGUgYFN0YXRlRmFjdG9yeWAgY2xhc3MgYWRkcyByb290IGFuZCBmZWF0dXJlIHN0YXRlcyB0byB0aGUgZ3JhcGguXG4gKiBUaGlzIGV4dHJhY3RzIHN0YXRlIG5hbWVzIGZyb20gc3RhdGUgY2xhc3NlcywgY2hlY2tzIGlmIHRoZXkgYWxyZWFkeVxuICogZXhpc3QgaW4gdGhlIGdsb2JhbCBncmFwaCwgdGhyb3dzIGVycm9ycyBpZiB0aGVpciBuYW1lcyBhcmUgaW52YWxpZCwgZXRjLlxuICogU2VlIGl0cyBjb25zdHJ1Y3Rvciwgc3RhdGUgZmFjdG9yaWVzIGluamVjdCBzdGF0ZSBmYWN0b3JpZXMgdGhhdCBhcmVcbiAqIHBhcmVudC1sZXZlbCBwcm92aWRlcnMuIFRoaXMgaXMgcmVxdWlyZWQgdG8gZ2V0IGZlYXR1cmUgc3RhdGVzIGZyb20gdGhlXG4gKiBpbmplY3RvciBvbiB0aGUgc2FtZSBsZXZlbC5cbiAqXG4gKiBUaGUgYE5neHNNb2R1bGUuZm9yRmVhdHVyZSguLi4pYCByZXR1cm5zIGBwcm92aWRlcnM6IFtTdGF0ZUZhY3RvcnksIC4uLnN0YXRlc11gLlxuICogVGhlIGBTdGF0ZUZhY3RvcnlgIGlzIGluaXRpYWxpemVkIG9uIHRoZSBmZWF0dXJlIGxldmVsIGFuZCBnb2VzIHRocm91Z2ggYC4uLnN0YXRlc2BcbiAqIHRvIGdldCB0aGVtIGZyb20gdGhlIGluamVjdG9yIHRocm91Z2ggYGluamVjdG9yLmdldChzdGF0ZSlgLlxuICogQGlnbm9yZVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfYWN0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnksXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElOSVRJQUxfU1RBVEVfVE9LRU4pXG4gICAgcHJpdmF0ZSBfaW5pdGlhbFN0YXRlOiBhbnlcbiAgKSB7fVxuXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xuXG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlc0J5TmFtZTogU3RhdGVzQnlOYW1lID0ge307XG5cbiAgZ2V0IHN0YXRlc0J5TmFtZSgpOiBTdGF0ZXNCeU5hbWUge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXNCeU5hbWUgOiB0aGlzLl9zdGF0ZXNCeU5hbWU7XG4gIH1cblxuICBwcml2YXRlIF9zdGF0ZVBhdGhzOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fTtcblxuICBwcml2YXRlIGdldCBzdGF0ZVBhdGhzKCk6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlUGF0aHMgOiB0aGlzLl9zdGF0ZVBhdGhzO1xuICB9XG5cbiAgZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCA9IG1lbW9pemUoKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgIGNvbnN0IHN0YXRlRmFjdG9yeSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBwYXRoID0gc3RhdGVGYWN0b3J5LnN0YXRlUGF0aHNba2V5XTtcbiAgICAgIHJldHVybiBwYXRoID8gcHJvcEdldHRlcihwYXRoLnNwbGl0KCcuJyksIHN0YXRlRmFjdG9yeS5fY29uZmlnKSA6IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCA9IHRoaXMuX3BhcmVudEZhY3RvcnlcbiAgICAgID8gdGhpcy5fcGFyZW50RmFjdG9yeS5nZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0KClcbiAgICAgIDoge1xuICAgICAgICAgIGdldFN0YXRlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gcmVzb2x2ZUdldHRlcihrZXkpO1xuICAgICAgICAgICAgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIExhdGUgbG9hZGVkIGdldHRlclxuICAgICAgICAgICAgICBpZiAoIWdldHRlcikge1xuICAgICAgICAgICAgICAgIGdldHRlciA9IHJlc29sdmVHZXR0ZXIoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyKC4uLmFyZ3MpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbE9wdGlvbnM/OiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHN0YXRlRmFjdG9yeS5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmdsb2JhbFNlbGVjdG9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4uKGxvY2FsT3B0aW9ucyB8fCB7fSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9KTtcblxuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZmF1bHRzKGRlZmF1bHRzOiBhbnkpOiBhbnkge1xuICAgIGxldCB2YWx1ZSA9IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcbiAgICAgIHZhbHVlID0geyAuLi5kZWZhdWx0cyB9O1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBkZWZhdWx0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXG4gICAqL1xuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IE1hcHBlZFN0b3JlW10ge1xuICAgIGlmIChOR19ERVZfTU9ERSkge1xuICAgICAgU3RvcmVWYWxpZGF0b3JzLmNoZWNrVGhhdFN0YXRlQ2xhc3Nlc0hhdmVCZWVuRGVjb3JhdGVkKHN0YXRlQ2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBuZXdTdGF0ZXMgfSA9IHRoaXMuYWRkVG9TdGF0ZXNNYXAoc3RhdGVDbGFzc2VzKTtcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHN0YXRlR3JhcGg6IFN0YXRlS2V5R3JhcGggPSBidWlsZEdyYXBoKG5ld1N0YXRlcyk7XG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBwYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IG5hbWVHcmFwaDogUGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+ID0gbmFtZVRvU3RhdGUobmV3U3RhdGVzKTtcbiAgICBjb25zdCBib290c3RyYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCA9IG5hbWVHcmFwaFtuYW1lXTtcbiAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IHBhdGhzW25hbWVdO1xuICAgICAgY29uc3QgbWV0YTogTWV0YURhdGFNb2RlbCA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcblxuICAgICAgdGhpcy5hZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhLCBwYXRoKTtcblxuICAgICAgLy8gTm90ZTogcHJldmlvdXNseSB3ZSBjYWxsZWQgYGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGVgIHdpdGhpbiB0aGVcbiAgICAgIC8vIGBTdGF0ZWAgZGVjb3JhdG9yLiBUaGlzIGNoZWNrIGlzIG1vdmVkIGhlcmUgYmVjYXVzZSB0aGUgYMm1cHJvdmAgcHJvcGVydHlcbiAgICAgIC8vIHdpbGwgbm90IGV4aXN0IG9uIHRoZSBjbGFzcyBpbiBKSVQgbW9kZSAoYmVjYXVzZSBpdCdzIHNldCBhc3luY2hyb25vdXNseVxuICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbiB0aHJvdWdoIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgKS5cbiAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZShzdGF0ZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5LmNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcbiAgICAgIH07XG5cbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgLy8gYnV0IGRvbid0IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIHBhdGgpKSB7XG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0c1xuICAgKi9cbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlc0FuZERlZmF1bHRzIHtcbiAgICBjb25zdCBjbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IHN0YXRlQ2xhc3NlcyB8fCBbXTtcblxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IHRoaXMuYWRkKGNsYXNzZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gbWFwcGVkU3RvcmVzLnJlZHVjZShcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxuICAgICAgICBzZXRWYWx1ZShyZXN1bHQsIG1hcHBlZFN0b3JlLnBhdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcbiAgfVxuXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpOiB2b2lkIHtcbiAgICAvLyBOb3RlOiBXZSBoYXZlIHRvIGNvbm5lY3QgYWN0aW9ucyBvbmx5IG9uY2Ugd2hlbiB0aGUgYFN0YXRlRmFjdG9yeWBcbiAgICAvLyAgICAgICBpcyBiZWluZyBjcmVhdGVkIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBjaGVja3MgaWYgd2UncmUgaW5cbiAgICAvLyAgICAgICBhIGNoaWxkIHN0YXRlIGZhY3RvcnkgYW5kIHRoZSBwYXJlbnQgc3RhdGUgZmFjdG9yeSBhbHJlYWR5IGV4aXN0cy5cbiAgICBpZiAodGhpcy5fcGFyZW50RmFjdG9yeSB8fCB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGF0Y2hlZCQgPSBuZXcgU3ViamVjdDxBY3Rpb25Db250ZXh0PigpO1xuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLl9hY3Rpb25zXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcbiAgICAgICAgbWVyZ2VNYXAoY3R4ID0+IHtcbiAgICAgICAgICBkaXNwYXRjaGVkJC5uZXh0KGN0eCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9uID0gY3R4LmFjdGlvbjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2VBY3Rpb25zKGRpc3BhdGNoZWQkLCBhY3Rpb24hKS5waXBlKFxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PlxuICAgICAgICAgICAgICBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXG4gICAqL1xuICBpbnZva2VBY3Rpb25zKGRpc3BhdGNoZWQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+LCBhY3Rpb246IGFueSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbikhO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZGlzcGF0Y2hlZCBhY3Rpb24gaGFzIGJlZW4gaGFuZGxlZCwgdGhpcyBpcyBhc3NpZ25lZFxuICAgIC8vIHRvIGB0cnVlYCB3aXRoaW4gdGhlIGJlbG93IGBmb3JgIGxvb3AgaWYgYW55IGBhY3Rpb25NZXRhc2AgaGFzIGJlZW4gZm91bmQuXG4gICAgbGV0IGFjdGlvbkhhc0JlZW5IYW5kbGVkID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICBjb25zdCBhY3Rpb25NZXRhcyA9IG1ldGFkYXRhLmFjdGlvbnNbdHlwZV07XG5cbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGEgb2YgYWN0aW9uTWV0YXMpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YS5pbnN0YW5jZVthY3Rpb25NZXRhLmZuXShzdGF0ZUNvbnRleHQsIGFjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgb2JzZXJ2YWJsZSBoYXMgYmVlbiBjb21wbGV0ZWQgdy9vIGVtaXR0aW5nXG4gICAgICAgICAgICAgIC8vIGFueSB2YWx1ZSB0aGVuIHdlIHdvdWxkbid0IHdhbnQgdG8gY29tcGxldGUgdGhlIHdob2xlIGNoYWluXG4gICAgICAgICAgICAgIC8vIG9mIGFjdGlvbnMuIFNpbmNlIGlmIGFueSBvYnNlcnZhYmxlIGNvbXBsZXRlcyB0aGVuXG4gICAgICAgICAgICAgIC8vIGFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UgaWYgYW55IGFjdGlvbiBoYW5kbGVyIHdvdWxkJ3ZlIGhhZCBzdWNoIHN0YXRlbWVudDpcbiAgICAgICAgICAgICAgLy8gYGhhbmRsZXIoY3R4KSB7IHJldHVybiBFTVBUWTsgfWBcbiAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9pc3N1ZXMvMTU2OFxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICBtZXJnZU1hcCgodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KHt9KVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBvZkFjdGlvbkRpc3BhdGNoZWQgc2hvdWxkIGJlIHVzZWQgd2l0aCBhY3Rpb24gY2xhc3NcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChkaXNwYXRjaGVkJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24gYXMgYW55KSkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gb2Yoe30pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3Rpb25IYXNCZWVuSGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgYE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyYCBpcyBhIHRyZWUtc2hha2FibGUgY2xhc3Mgd2hpY2ggZnVuY3Rpb25zXG4gICAgLy8gb25seSBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gICAgaWYgKE5HX0RFVl9NT0RFICYmICFhY3Rpb25IYXNCZWVuSGFuZGxlZCkge1xuICAgICAgY29uc3QgdW5oYW5kbGVkQWN0aW9uc0xvZ2dlciA9IHRoaXMuX2luamVjdG9yLmdldChOZ3hzVW5oYW5kbGVkQWN0aW9uc0xvZ2dlciwgbnVsbCk7XG4gICAgICAvLyBUaGUgYE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyYCB3aWxsIG5vdCBiZSByZXNvbHZlZCBieSB0aGUgaW5qZWN0b3IgaWYgdGhlXG4gICAgICAvLyBgTmd4c0RldmVsb3BtZW50TW9kdWxlYCBpcyBub3QgcHJvdmlkZWQuIEl0J3MgZW5vdWdoIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGBpbmplY3Rvci5nZXRgXG4gICAgICAvLyBkaWRuJ3QgcmV0dXJuIGBudWxsYCBzbyB3ZSBtYXkgZW5zdXJlIHRoZSBtb2R1bGUgaGFzIGJlZW4gaW1wb3J0ZWQuXG4gICAgICBpZiAodW5oYW5kbGVkQWN0aW9uc0xvZ2dlcikge1xuICAgICAgICB1bmhhbmRsZWRBY3Rpb25zTG9nZ2VyLndhcm4oYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICByZXN1bHRzLnB1c2gob2Yoe30pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ya0pvaW4ocmVzdWx0cyk7XG4gIH1cblxuICBwcml2YXRlIGFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiB7XG4gICAgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXTtcbiAgfSB7XG4gICAgY29uc3QgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IFtdO1xuICAgIGNvbnN0IHN0YXRlc01hcDogU3RhdGVzQnlOYW1lID0gdGhpcy5zdGF0ZXNCeU5hbWU7XG5cbiAgICBmb3IgKGNvbnN0IHN0YXRlQ2xhc3Mgb2Ygc3RhdGVDbGFzc2VzKSB7XG4gICAgICBjb25zdCBzdGF0ZU5hbWUgPSBnZXRTdG9yZU1ldGFkYXRhKHN0YXRlQ2xhc3MpLm5hbWUhO1xuICAgICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICAgIFN0b3JlVmFsaWRhdG9ycy5jaGVja1RoYXRTdGF0ZU5hbWVJc1VuaXF1ZShzdGF0ZU5hbWUsIHN0YXRlQ2xhc3MsIHN0YXRlc01hcCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bm1vdW50ZWRTdGF0ZSA9ICFzdGF0ZXNNYXBbc3RhdGVOYW1lXTtcbiAgICAgIGlmICh1bm1vdW50ZWRTdGF0ZSkge1xuICAgICAgICBuZXdTdGF0ZXMucHVzaChzdGF0ZUNsYXNzKTtcbiAgICAgICAgc3RhdGVzTWFwW3N0YXRlTmFtZV0gPSBzdGF0ZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG5ld1N0YXRlcyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhOiBNZXRhRGF0YU1vZGVsLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlUGF0aHNbbWV0YS5uYW1lIV0gPSBwYXRoO1xuICAgIC8vIFRPRE86IHY0IC0gd2UgcGxhbiB0byBnZXQgcmlkIG9mIHRoZSBwYXRoIHByb3BlcnR5IGJlY2F1c2UgaXQgaXMgbm9uLWRldGVybWluaXN0aWNcbiAgICAvLyB3ZSBjYW4gZG8gdGhpcyB3aGVuIHdlIGdldCByaWQgb2YgdGhlIGluY29ycmVjdGx5IGV4cG9zZWQgZ2V0U3RvcmVNZXRhZGF0YVxuICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjb21lIHVwIHdpdGggYW4gYWx0ZXJuYXRpdmUgaW4gdjQgYmVjYXVzZSB0aGlzIGlzIHVzZWQgYnkgbWFueSBwbHVnaW5zXG4gICAgbWV0YS5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU6IGJvb2xlYW4gPVxuICAgICAgZ2V0VmFsdWUodGhpcy5faW5pdGlhbFN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIFRoaXMgY2hlY2tzIHdoZXRoZXIgYSBzdGF0ZSBoYXMgYmVlbiBhbHJlYWR5IGFkZGVkIHRvIHRoZSBnbG9iYWwgZ3JhcGggYW5kXG4gICAgLy8gaXRzIGxpZmVjeWNsZSBpcyBpbiAnYm9vdHN0cmFwcGVkJyBzdGF0ZS5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xuICB9XG59XG4iXX0=